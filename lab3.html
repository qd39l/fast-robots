<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="Github web page for ECE 5960: Design and Implementation of fast robots (2022SP)." />
        <meta name="author" content="Owen Deng (qd39@cornell.edu)" />
        <!-- FIXME -->
        <title>Fast Robots: Lab 3</title>
        <link rel="icon" type="image/x-icon" href="assets/ai.png" />
        <!-- Font Awesome icons (free version)-->
        <script src="https://use.fontawesome.com/releases/v5.15.4/js/all.js" crossorigin="anonymous"></script>
        <!-- Google fonts-->
        <link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css" />
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="css/styles.css" rel="stylesheet" />
    </head>
    <body>
        <!-- Navigation-->
        <nav class="navbar navbar-expand-lg navbar-light" id="mainNav">
            <div class="container px-4 px-lg-5">
                <a class="navbar-brand" href="index.html">Fast Robots: Lab Notebook</a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                    Menu
                    <i class="fas fa-bars"></i>
                </button>
                <div class="collapse navbar-collapse" id="navbarResponsive">
                    <ul class="navbar-nav ms-auto py-4 py-lg-0">
                        <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="index.html">Home</a></li>
                        <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="about.html">About</a></li>
                        <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="contact.html">Contact</a></li>
                    </ul>
                </div>
            </div>
        </nav>
        <!-- Page Header-->
        <!-- FIXME -->
        <header class="masthead" style="background-image: url('assets/img/lab3/background.jpg')">
            <div class="container position-relative px-4 px-lg-5">
                <div class="row gx-4 gx-lg-5 justify-content-center">
                    <div class="col-md-10 col-lg-8 col-xl-7">
                        <div class="post-heading">
                            <h1>Sensors</h1>
                            <h2 class="subheading">The Artemis board now becomes Doctor Octopus!</h2>
                            <span class="meta">
                                Posted by
                                <a href="#!">Owen Deng</a>
                                on February 22, 2022
                            </span>
                        </div>
                    </div>
                </div>
            </div>
        </header>
        <!-- Post Content-->
        <article class="mb-4">
            <div class="container px-4 px-lg-5">
                <div class="row gx-4 gx-lg-5 justify-content-center">
                    <div class="col-md-10 col-lg-8 col-xl-7">
                        <p> 
                            <mark>WARNING: This writeup is long because the lab is long... Please be aware...</mark>
                        </p>

                        <p> 
                            The goal of this lab is to connect the sensors to the robot, and to characterize the capabilities of the sensors we are using.
                            Intuitively, the capabilities of our robot is limited by the capabilities of the sensors. (we don't want the robot to be randomly 
                            crashing on things...) Therefore, the faster our sensors can sample data, the faster the robot can move. Similarly, more accurate
                            sensors lead to better control of the robot. In this course, the robot has three external sensing components: two Time-of-Flight 
                            Sensors (ToF) and an Inertial Measurement Unit (IMU). These sensors are provided by the course staff and they all come in the form
                            of breakout boards. </p>

                        <p> 
                            When it comes to sensors, it's important to have access to the sensors' specifications as well as their API libraries (unless we're writing
                            our own which we are not). For the ToF sensor (VL53L1X), we have access to the 
                            <a href="https://cdn.sparkfun.com/assets/e/1/8/4/e/VL53L1X_API.pdf" class="link-primary">manual</a>, 
                            the <a href="https://cdn.sparkfun.com/assets/8/9/9/a/6/VL53L0X_DS.pdf" class="link-primary">datasheet</a>, and the 
                            <a href="https://github.com/sparkfun/SparkFun_VL53L1X_Arduino_Library/blob/master/src/SparkFun_VL53L1X.h" class="link-primary">headerfile</a>
                            of the corresponding Arduino library. 
                            
                            For the IMU (ICM 20948), we have access to its 
                            <a href="https://invensense.tdk.com/wp-content/uploads/2016/06/DS-000189-ICM-20948-v1.3.pdf" class="link-primary">datasheet</a> and the 
                            <a href="https://github.com/sparkfun/SparkFun_ICM-20948_ArduinoLibrary" class="link-primary">Arduino library</a> for controlling this sensor.
                        </p>

                        <h2 class="section-heading">Hooking up the sensors</h2>
                        <p> 
                            All the external sensors communicate with the Artemis board via 
                            <a href="https://en.wikipedia.org/wiki/I%C2%B2C" class="link-primary">I2C protocol</a>. 
                            The Artemis board is the I2C controller, and the sensor components are I2C targets. (Many are more familiar with the nomenclature "master/slave", which
                            was updated in 
                            <a href="https://www.nxp.com/docs/en/user-guide/UM10204.pdf" class="link-primary">I2C Spec Rev. 07</a>.)
                        </p>

                        <p>
                            Wiring between the Artemis board and the sensor boards are straight-forward. Coming from the I2C protocl, each sensor board needs at least four connections ( 
                            <code>Vin</code>,
                            <code>Ground</code>,
                            <code>SDA</code>, and 
                            <code>SCL</code>) to the Artemis controller for data exchange to work. The picture below shows the pinout of each board. I have soldered jump wire connectors
                            onto the boards.
                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/sensor-headers.jpg" width = 400 alt="..." /></a>
                            <span class="caption text-muted">Pinout of sensor boards. The green one on top is the ToF sensor. The black one below is the IMU.</span>

                            Notice that both boards have the four necessary signal pins available. In a "one controller, many target" setup, the same signals from each board share the same electrical node, e.g., 
                            the <code>SDA</code> pin of the Artemis board is connected to the <code>SDA</code> pin of both ToF boards and the IMU board. 
                        </p>

                        <p>
                            With some soldering work done, the Artemis board essentially turns into Doc Ock... See the picture below
                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/wiring.jpg" width = 600 alt="..." /></a>
                            <span class="caption text-muted">The Artemis board connected to the sensors.</span>

                            To summarize my wiring:
                            <ul class="list-unstyled">
                                <ul>
                                  <li>Some jump wire pins are soldered to a protoboard. The protoboard is used for better cable management. Connections are made on the back. </li>
                                  <li>Both ToF sensors' <code>XSHUT</code> pins are wired to a GPIO pin (<code>PIN7</code> & <code>PIN8</code> used) on the Artemis board (with jump wire connection). This is needed because both ToF sensors 
                                      share the same I2C address.</li>
                                  <li>Cables are braided because I found it fun.</li>
                                </ul>
                            </ul>
                            
                            I chose jump wire connections to hopefully avoid any future re-work and improved modularity. Also note that the Artemis board has the 
                            <a href="https://www.sparkfun.com/qwiic" class="link-primary">SparkFun Qwiic Connect System</a> for cleaner I2C connections on the board.

                            
                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/wiring-closeup1.jpg" width = 600 alt="..." /></a>
                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/wiring-closeup2.jpg" width = 600 alt="..." /></a>
                            <span class="caption text-muted">Shows the wiring between the Artemis board and the sensors (two perspectives).</span>

                        </p>
                        
                        <h2 class="section-heading">Software preparation</h2>
                        Two Arduino libraries need to be installed so that we can access the API for interacting with the sensors.
                        <ul class="list-unstyled">
                            <ul>
                              <li>SparkFun VL53L1X 4m laser distance sensor library <a href="https://github.com/sparkfun/SparkFun_VL53L1X_Arduino_Library" class="link-primary">(source code)</a></li>
                              <li>SparkFun 9DOF IMU Breakout - ICM 20948 <a href="https://github.com/sparkfun/SparkFun_ICM-20948_ArduinoLibrary" class="link-primary">(source code)</a></li>
                            </ul>
                        </ul>

                        <mark>Assuming everything is set up properly (in reality some circuit debugging efforts were involved for sure...), let's hop on to the actual lab tasks!! </mark>

                        <h2 class="section-heading">Lab 3(a): Time of Flight sensors</h2>
                        <h3 class="section-subheading">I2C addresses</h3>
                        <p>
                            To instructors: I didn't run the Wire example since it doesn't work well... I jumped straight into the read-distance example, and completed the two sensor setup.
                        </p>

                        <h3 class="section-subheading">Sensing modes and sensor characterizations</h3>
                        <p>
                            The <a href="https://cdn.sparkfun.com/assets/e/1/8/4/e/VL53L1X_API.pdf" class="link-primary">API document</a> claims there are three distance modes in in section 2.5.3. However, the <a href="https://github.com/sparkfun/SparkFun_VL53L1X_Arduino_Library/blob/master/src/SparkFun_VL53L1X.h" class="link-primary">SparkFun API headerfile</a> only provides two distance modes. Therefore, we assume only two distance modes are accessible by the user (myself). The table below summarizes the pros/cons of each mode. To determine which mode to be used, I conducted some characterizations on the sensors.

                            <table class="table">
                                <thead>
                                  <tr>
                                    <th scope="col">Possible distance modes</th>
                                    <th scope="col">Maximum distance</th>
                                    <th scope="col">Benefit/comments</th>
                                  </tr>
                                </thead>
                                <tbody>
                                  <tr>
                                    <th scope="row">Short (default)</th>
                                    <td>Up to 1.3 m</td>
                                    <td>Better ambient immunity</td>
                                  </tr>
                                  <tr>
                                    <th scope="row">Long</th>
                                    <td>Up to 4 m</td>
                                    <td>Maximum distance</td>
                                  </tr>
                                </tbody>
                            </table>
                            <span class="caption text-muted">A summary of the two distance modes available on VL53L1X.</span>
                        </p>

                        <h4 class="section-subsubheading">1. Distance modes and accuracy</h4>

                        <p>
                            To investigate the impact of distance modes, I conducted a sweep of measured distances and the actual distances for the two modes. The sensor module is mounted on the back of my laptop. The sensor module is facing a wall, and a ruler is used to measure the distance between itself and the wall. Measured data are streamed to the laptop through the serial port. Pictures below shows the setup.

                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/distance-setup1.jpg" width = 600 alt="..." /></a>
                            <span class="caption text-muted">The laptop is facing the wall. Artemis is connected to the laptop, and data is read on the Serial monitor. </span>

                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/distance-setup2.jpg" width = 600 alt="..." /></a>
                            <span class="caption text-muted">The sensor module is mounted on the back of the laptop. The paper is necessary because the laptop surface is conductive. (took me a while to debug) </span>
                        </p>

                        <p>
                            Data are visualized with Matplotlib. 

                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/distance-plot.png" width = 600 alt="..." /></a>
                            <span class="caption text-muted"> Plotting the ref distance and the measured distances with two different measurement modes. </span>

                            Some important findings include:

                            <ul class="list-unstyled">
                                <ul>
                                  <li>Both short and long mode data are off for longer ref distance. This could be due to misalignments of the laptop and the wall. Just looking at the green and orange line, they are consistent.</li>
                                  <li>The short mode is rated for up to 1.3m, but turns out it is doing okay when going up to 2m.</a></li>
                                </ul>
                            </ul>

                            <mark>The ranging time</mark> is also measured. One sensor needs a consistent <code>87 ms</code> while another sensor only needs <code>3 ms</code>. The reason is unknown after some investigation efforts. <mark>The ranging time is independent of distance and/or distancing modes.</mark>
                        </p>

                        <h4 class="section-subsubheading">2. Lighting conditions, colors, and textures</h4>
                        <p>
                            The impact of lighting conditions, colors, and textures are also investigated. The sensor is placed 30 cm away from a white box. Their positions are kept the same throughout this experiment, while other factors are tuned. 50 measurements are taken, and the mean is reported. Because 30 cm is short, the short distancing mode is chosen throughout. The table blow summarizes my findings.

                            <table class="table">
                                <thead>
                                  <tr>
                                    <th scope="col">Distance modes</th>
                                    <th scope="col">Color</th>
                                    <th scope="col">Texture</th>
                                    <th scope="col">Lighting</th>
                                    <th scope="col">Measured Distance (mm)</th>
                                  </tr>
                                </thead>
                                <tbody>
                                  <tr>
                                    <td>Short</td>
                                    <td>White</td>
                                    <td>Smooth</td>
                                    <td>Ambient (LED)</td>
                                    <td>294</td>
                                  </tr>
                                  <tr>
                                    <td>Short</td>
                                    <td>White</td>
                                    <td>Smooth</td>
                                    <td>Bright Incandescent</td>
                                    <td>297</td>
                                  </tr>
                                  <tr>
                                    <td>Short</td>
                                    <td>White</td>
                                    <td>Smooth</td>
                                    <td>Dark</td>
                                    <td>301</td>
                                  </tr>
                                  <tr>
                                    <td>Short</td>
                                    <td>White</td>
                                    <td>Cloth</td>
                                    <td>Ambient (LED)</td>
                                    <td>298</td>
                                  </tr>
                                  <tr>
                                    <td>Short</td>
                                    <td>Blue</td>
                                    <td>Cloth</td>
                                    <td>Ambient (LED)</td>
                                    <td>300</td>
                                  </tr>
                                </tbody>
                            </table>
                            <span class="caption text-muted">Table summarizing the impacts of lighting conditions, colors, and textures.</span>

                            The pictures below show my setup for this experiment.
                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/distance-setup3.jpg" width = 600 alt="..." /></a>
                            <span class="caption text-muted"> The laptop and the box. </span>
                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/distance-setup4.jpg" width = 600 alt="..." /></a>
                            <span class="caption text-muted"> The incandescent light. </span>
                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/distance-setup5.jpg" width = 600 alt="..." /></a>
                            <span class="caption text-muted"> The box wrapped in blue cloth. </span>

                            In conclusion, with the short distancing mode, the ToF sensor is not affected by lighting conditions, colors, and textures. <mark>Given these characterization results, I decide to go with the short distancing mode because a) it works for up to 2m without any obvious issues, b) it is robust against lighting conditions, colors, and textures, and c) it is the default mode so programming becomes a little bit easier.</mark>
                        </p>

                        <h4 class="section-subsubheading">Code Snippets</h4>
                        <p>
                            A wrapper class, <code>MyToFSensor</code>, is created to interface with the ToF sensor modules. The details of this wrapper class is attached to the end of this page. This section assumes the existance of this class and provides a high-level view of how the Artemis is set up for this experiment. The program simply gets the measurement and the time for measuring, and pipes the result to the Serial monitor for me to view.

                            <pre>
                                <code>
// Arduino library
#include &ltArduino.h&gt
#include &ltWire.h&gt

// my ToF sensor wrapper
#include "tof_sensors.h"

MyToFSensor my_tof;

void setup(void)
{
    Wire.begin();

    // TOF init
    Serial.begin(115200);
    Serial.println("ToF setup");
    my_tof.init();
    Serial.println("Sensor online!");
}

void loop(void)
{
    Serial.print("Sensor0 Distance(mm): ");
    distance_sensor_result sensor0_result = my_tof.get_measurement(0);
    Serial.print(sensor0_result.distance);
    Serial.print(" Sensor0 time(ms): ");
    Serial.print(sensor0_result.measuring_time);

    Serial.print("      Sensor1 Distance(mm): ");
    distance_sensor_result sensor1_result = my_tof.get_measurement(1);
    Serial.print(sensor1_result.distance);
    Serial.print(" Sensor1 time(ms): ");
    Serial.print(sensor1_result.measuring_time);

    Serial.println();
}

                                </code>
                            </pre>
                        </p>


                        <h3 class="section-subheading">Working with two sensors simultaneously</h3>
                        <p>
                            There are a total of 2 ToF sensor modules on the same I2C channel. They have the same I2C address, so additional setups are needed to use them simultaneously.
                        </p>

                        <p>
                            During sensor initialization, the <code>XSHUT</code> pin of one sensor is asserted <code>LOW</code>. Then the init method of the other sensor is called, and subsequently its I2C address is modified. After that, the <code>XSHUT</code> pin is pulled high, bring the first sensor back online with the default address. At this point, two ToF sensors have different I2C addresses, and they can be used simultaneously. Code snippet attached below.

                            <pre>
                                <code>
pinMode(SHUTDOWN_PIN_0, OUTPUT);
pinMode(SHUTDOWN_PIN_1, OUTPUT);

digitalWrite(SHUTDOWN_PIN_0, LOW);
digitalWrite(SHUTDOWN_PIN_1, HIGH);

if (this->distanceSensor_1.begin() != 0) // Begin returns 0 on a good init
{
    Serial.println("Sensor 1 failed to begin. Please check wiring. Freezing...");
    while (1)
        ;
}

this->distanceSensor_1.setI2CAddress(0x60);

digitalWrite(SHUTDOWN_PIN_0, HIGH);

if (this->distanceSensor_0.begin() != 0) // Begin returns 0 on a good init
{
    Serial.println("Sensor 0 failed to begin. Please check wiring. Freezing...");
    while (1)
        ;
}
                                </code>
                            </pre>

                        </p>

                        <h3 class="section-subheading">A1: Discussion on infrared transmission distance sensors</h3>

                        <p>
                            Many distance sensors are based on infrared transmission, including IR distance sensors, LiDAR, and Time-of-Flight sensors.  
                        </p>

                        <p>
                            IR distance sensors are cheap. Measurement is based on the reflected angle of the beam. The picture below is an intuitive picture of its working principle.

                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/IR.jpg" width = 600 alt="..." /></a>
                            <span class="caption text-muted"> IR distance sensor working principle. Source: https://os.mbed.com/forum/mbed/topic/1048/?page=1#comment-6420 </span>

                            Despite its cheap price and better relibaility than an even-cheaper ultrasonic proximity sensor, it is not able to measure accurately for long distance. As the distance gets longer, the change of angle becomes smaller and undetectable. They also fail if the object is highly reflective (like a mirror).
                        </p>

                        <p>
                            ToF sensors take advantages of the constant speed of light. The picture below shows its principle. The emitter sends a pulse of EM wave, which is reflected by the objected and later picked up by the receiver. The distance between the sensor and the object and then be calculated from the time between the emitter sends the pulse and the receiver picks up the pulse.

                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/tof.png" width = 600 alt="..." /></a>
                            <span class="caption text-muted"> ToF sensors principle. Source: https://en.wikipedia.org/wiki/Time_of_flight </span>

                            ToF sensors are better in long distance sensing, and the sampling frequency is typically higher. However, this comes with the cost of being more expensive than IR proximity sensors.
                        </p>

                        <p>
                            LiDAR uses a similar principle as ToF sensors: pulsed lasers are used, and the travelling time of the pulsed is used to calculate the distance. However, LiDAR typically uses an array of emitters and receivers, making them better in doing 3D sensing and imaging, and they are more robust than ToF sensors. This comes with the cost of being very expensive compared to other IR-based sensors. (fancy!)
                        </p>

                        <p>
                            Reference for writing this section:
                            <ul class="list-unstyled">
                                <ul>
                                  <li>https://www.makeuseof.com/tof-and-lidar-difference/</li>
                                  <li>https://www.seeedstudio.com/blog/2019/12/23/distance-sensors-types-and-selection-guide/</li>
                                  <li>https://www.sparkfun.com/distance_sensor_comparison_guide</li>
                                </ul>
                            </ul>
                        </p>

                        <h3 class="section-subheading">A2: Timing budget</h3>

                        <p>
                            Recall that earlier in this article, I reported that one sensor needs a consistent <code>87 ms</code> while another sensor only needs <code>3 ms</code> when doing a measurement. This section could shine some light on why that was the case.
                        </p>

                        <p>
                            Each ToF sensor can be configured with a <mark>timing budget</mark> and an <mark>inter-measurement period</mark>, both in milliseconds. Timing budget is the time required by the sensor to perform one range measurement, and the inter-measurement period is the delay between two ranging operations. The minimum and maximum timing budgets are [<code>20 ms</code>, <code>1000 ms</code>]. 

                            I first read out the default values.

                            <pre>
                                <code>
Serial.print("Sensor 0 timing budget: ");
Serial.println(this->distanceSensor_0.getTimingBudgetInMs());
Serial.print("Sensor 0 intermeasurement period: ");
Serial.println(this->distanceSensor_0.getIntermeasurementPeriod());
Serial.print("Sensor 1 timing budget: ");
Serial.println(this->distanceSensor_1.getTimingBudgetInMs());
Serial.print("Sensor 1 intermeasurement period: ");
Serial.println(this->distanceSensor_1.getIntermeasurementPeriod());
                                </code>
                            </pre>

                            The sensors have the following default configurations:
                            <table class="table">
                                <thead>
                                  <tr>
                                    <th scope="col">Sensor Number</th>
                                    <th scope="col">Intermeasurement Period (ms)</th>
                                    <th scope="col">Timing Budget (ms)</th>
                                  </tr>
                                </thead>
                                <tbody>
                                  <tr>
                                    <td>0</td>
                                    <td>100</td>
                                    <td>0</td>
                                  </tr>
                                  <tr>
                                    <td>1</td>
                                    <td>98</td>
                                    <td>0</td>
                                  </tr>
                                </tbody>
                            </table>
                            Weirdly, not only both timing budgets are default to 0, the intermeasurement period are also different... despite they are the exact same module. This may (or may not) explain why one sensor's reading time is much longer than the other.
                        </p>

                        <p>
                            Then I poked with the numbers and obtained the following numbers.

                            <table class="table">
                                <thead>
                                  <tr>
                                    <th scope="col">Sensor Number</th>
                                    <th scope="col">Intermeasurement Period (ms)</th>
                                    <th scope="col">Timing Budget (ms)</th>
                                    <th scope="col">Measuring Time (ms)</th>
                                  </tr>
                                </thead>
                                <tbody>
                                  <tr>
                                    <td>0</td>
                                    <td>0</td>
                                    <td>20</td>
                                    <td>Fail to take measurements</td>
                                  </tr>
                                  <tr>
                                    <td>1</td>
                                    <td>0</td>
                                    <td>20</td>
                                    <td>Fail to take measurements</td>
                                  </tr>
                                  <tr>
                                    <td>0</td>
                                    <td>20</td>
                                    <td>20</td>
                                    <td>4</td>
                                  </tr>
                                  <tr>
                                    <td>1</td>
                                    <td>20</td>
                                    <td>20</td>
                                    <td>10</td>
                                  </tr>
                                  <tr>
                                    <td>0</td>
                                    <td>100</td>
                                    <td>100</td>
                                    <td>60</td>
                                  </tr>
                                  <tr>
                                    <td>1</td>
                                    <td>100</td>
                                    <td>100</td>
                                    <td>80</td>
                                  </tr>
                                </tbody>
                            </table>

                            I did not notice any reliability issues associated with the change of these two configurations.
                        </p>

                        <p>
                            A longer intermeasurement period can save energy (the module goes into low-power mode when idle). However, energy is out of our concern since the robot is not designed to move for a long time. It is expected to move FAST! <mark>Therefore, I decided to set both values to <code>20 ms</code> for subsequent labs because I want the robot to be able to take samples as quickly as possible. Such that it can move and respond as fast as possible!</mark>
                        </p>

                        <h3 class="section-subheading">A3: Signal and Sigma: is the measurement valid?</h3>
                        <p>
                            The driver uses two parameters to qualify the ranging measurement: signal and sigma. If signal or sigma are outside the limits, the ranging is flagged as invalid.
                        </p>

                        <p>
                            Sigma is expressed in mm and is the estimation of the standard deviation of the measurement. The signal rate measurement represents the amplitude of the signal reflected from the target and detected by the device. Therefore, a small sigma and a large signal corresponds to a strong confidence in the measurement. The driver associates these two values with a tolerance limit. If signal or sigma are outside the limits, the ranging is flagged as invalid. The video below shows the results of running <code>Example3_StatusAndRate</code> of the ToF sensor library. 
                        </p>

                        <iframe width="820" height="515"
                        src="https://www.youtube.com/embed/qioRD9hZa0o">
                        </iframe>
                        <span class="caption text-muted">Demo of running <code>Example3_StatusAndRate</code>.</span>
                        
                        <p>
                            In the demo video, the ToF sensor is quickly flipped around. Whenever flipping happens, there are one or two data points where the range status shows "Signal fail" or "Wrapped target fail" (no signal detected). This provides a mean for us to filter out invalid readings. In future labs, we can implement checks against these invalid signals to make our robot more robust, especially when it is moving fast.
                        </p>

                        <p>
                            Software initialization of the IMU board is simple
                        </p>

                        <h2 class="section-heading">Lab 3(b): IMU</h2>

                        <h3 class="section-subheading">IMU setup and examples</h3>
                        
                        <p>
                            As shown in the <mark>Hooking up the sensors</mark> section, the IMU is connected to the Artemis board with I2C protocol, sharing the same I2C channel with two ToF sensors. The first task is to run the <mark>SparkFun Example (Example1_Basics)</mark> of the IMU breakout board.
                        </p>

                        <p>
                            Inside the <a href="https://github.com/sparkfun/SparkFun_ICM-20948_ArduinoLibrary/blob/main/examples/Arduino/Example1_Basics/Example1_Basics.ino" class="link-primary">Example1_Basics</a> code file in line 56, we see the subroutine <code>myICM.begin(WIRE_PORT, AD0_VAL)</code> is called to initialize the driver. <code>WIRE_PORT</code> is the I2C port, and <code>AD0_VAL</code> is defined to be 1. Looking at the comments around line 22, we see that <code>AD0_VAL</code> should be set to 1 when the ADR jumper is open, and should be set to 0 when it is closed. The ADR jumper is a physical connection on the breakout board. The picture below shows its position.

                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/ADR_jumper.jpg" width = 600 alt="..." /></a>
                            <span class="caption text-muted"> The ADR jumper labeled as <code>ADDR+1</code> </span>

                            The I2C address of this IMU module can be hardware-configured as <code>0x68</code> or <code>0x69</code>, depending on whether this jumper spot is open or close. Therefore, the driver SW needs to look at <code>AD0_VAL</code> such that it uses the correct I2C address for the IMU. This can also be confirmed by looking at the <a href="https://github.com/sparkfun/SparkFun_ICM-20948_ArduinoLibrary/blob/main/src/ICM_20948.cpp" class="link-primary">source code</a> of the the class <code>ICM_20948_I2C</code>
                        </p>

                        <p>
                            In our case, the circuit is opened. Therefore <code>AD0_VAL</code> should be set to 1 instead of the default value 0.
                        </p>

                        <p>
                            To better understanding what the IMU is measuring, I plotted the accelerometer and gyroscope data as I rotate, flip, and accelerate the board. To make coding in <code>main</code> easier, I wrote a wrapper called <code>MyIMU</code>. Assuming its existance, it's easy to continuously read data and feed data into the serial plotter. Below is the code snippet.
                            <pre>
                                <code>
// omit include statements

MyIMU my_imu;

void setup(void)
{
    Wire.begin();
    Wire.setClock(400000);

    my_imu.init();

    Serial.println("Sensors online!");
}

void loop(void)
{
    while (!my_imu.update_data()){};
    imu_data acc = my_imu.get_acc();
    Serial.print("Acc (x, y, z) = ");
    Serial.print(acc.x);
    Serial.print(", ");
    Serial.print(acc.y);
    Serial.print(", ");
    Serial.print(acc.z);
    Serial.println();

    delay(30);
}
                                </code>
                            </pre>

                            The video below shows how the accelerometer's (x, y, z) values change as I flip and rotate the board. In this case, the gravitational force is the only force acting on the board. Therefore, the readings change as the board is oriented differently to reflect the gravity's projection on the (x, y, z) axis. When the board is oriented "flat" and rotated around, the readings remain the same, the reason being that the gravity is acting only on the z-axis no matter how the board rotates.

                            <iframe width="820" height="515"
                            src="https://www.youtube.com/embed/FTGsjxuoPCg">
                            </iframe>
                            <span class="caption text-muted">Accelerometer data: flip and rotate.</span>

                            The video below shows how the readings change when the board is tapped. We notice sharp spikes because the board is first accelerated because of the tap and then bounced back. 

                            <iframe width="820" height="515"
                            src="https://www.youtube.com/embed/f62eVr8c4RY">
                            </iframe>
                            <span class="caption text-muted">Accelerometer data: tapping.</span>

                            The gyroscope measures angular velocity. When the board is flipped ro rotated, the corresponding angular velocity first increases then decreases. The same applies when the board is tapped. The video below demonstrates its behavior. Note that different from the accelerometer, the gyroscope readings are zeros when the board is not moving.

                            <iframe width="820" height="515"
                            src="https://www.youtube.com/embed/VgtkkzUtAnA">
                            </iframe>
                            <span class="caption text-muted">Gyroscope data: flip, rotate, and tap.</span>
                        </p>

                        <h3 class="section-subheading">Accelerometer: pitch and roll</h3>
                        <p>
                            To see how accurate the accelerometer is, I measured the output at {-90, 0, 90} degrees pitch and roll. The edges of my table is used as guides to ensure 90 degree tilt/roll. The table below shows the results.

                            <table class="table">
                                <thead>
                                  <tr>
                                    <th scope="col">Pitch/Roll</th>
                                    <th scope="col">Degrees</th>
                                    <th scope="col">Readings (x, y, z)</th>
                                    <th scope="col">$sqrt(x^2 + y^2 + z^2)</th>
                                  </tr>
                                </thead>
                                <tbody>
                                  <tr>
                                    <td>Pitch</td>
                                    <td>-90</td>
                                    <td>(999.02, 12.7, 7.32)</td>
                                    <td>999.13</td>
                                  </tr>
                                  <tr>
                                    <td>Pitch</td>
                                    <td>0</td>
                                    <td>(8.30, 0.49, 1105.47)</td>
                                    <td>1105.50</td>
                                  </tr>
                                  <tr>
                                    <td>Pitch</td>
                                    <td>90</td>
                                    <td>(-991.70, 70.31, 75.20)</td>
                                    <td>997.03</td>
                                  </tr>
                                  <tr>
                                    <td>Roll</td>
                                    <td>-90</td>
                                    <td>(-27.93, 1021.97, 57.13)</td>
                                    <td>1023.95</td>
                                  </tr>
                                  <tr>
                                    <td>Roll</td>
                                    <td>0</td>
                                    <td>(-50.29, -3.91, 1104.00)</td>
                                    <td>1105.15</td>
                                  </tr>
                                  <tr>
                                    <td>Roll</td>
                                    <td>90</td>
                                    <td>(-186.04, 960.45, 51.27)</td>
                                    <td>979.65</td>
                                  </tr>
                                </tbody>
                            </table>

                            Due to the shape of the board, it's still difficult to tell whether the board is perfectly aligning with the desired measuring angles (besides, my table could be tilted). However, for each measurement, we can tell that the gravitational force is mainly exerted on one axis only, and this is a good sanity check.
                        </p>

                        <p>
                            Looking at the values of <code>$sqrt(x^2 + y^2 + z^2)</code>, we can tell that our accelerometer is functional, but not very accurate. The variations could be as large as ~10%. This is telling me that we may need ~10% tolerance on the accelerometer values in future labs.
                        </p>

                        <h3 class="section-subheading">Accelerometer: tapping</h3>

                        <p>
                            In this task, I tapped the IMU board and plotted the frequency response of the accelerometer. The goal is to understand what frequency spectrum the "unwanted noise" have, such that we could choose a complimentary low pass filter cut off frequency in later labs to filter out these noise (assuming the robot is moving much slower than the noise). The "output" of the accelerometer is the square root of the square sum of (x, y, z) for an easier while still meaningful implementation.
                        </p>

                        <p>
                            The accelerometer data is streamed through Serial monitor, and the raw data is copied over to Python for FFT analysis. Below is the code snippet for Arduino.
                        </p>

                        <pre>
                            <code>
// ----------------- Arduino Code --------------------
// Arduino library

// omit include statements

MyIMU my_imu;
unsigned long start_time;

void setup(void)
{
    Wire.begin();
    Wire.setClock(400000);

    Serial.begin(115200);
    while (!Serial)
    {
    };

    Serial.println("IMU setup");
    my_imu.init();

    Serial.println("Sensors online!");

    start_time = millis(); // start timer
}

void loop(void)
{
    while (!my_imu.update_data()){};
    imu_data acc = my_imu.get_acc();
    Serial.print("[");
    Serial.print(acc.x);
    Serial.print(", ");
    Serial.print(acc.y);
    Serial.print(", ");
    Serial.print(acc.z);
    Serial.print("],");

    Serial.println();

    while (millis() - start_time >= 5000){
        Serial.print("measurement done.");
        Serial.println();
        delay(1000);
    } // trap the program at 5 s
}

                            </code>
                        </pre>

                        <p>Below is the code snippet for Python.</p>

                        <pre>
                            <code>
import numpy as np
import matplotlib.pyplot as plt
from scipy import pi
from scipy.fftpack import fft

time_data_raw = [
    # put raw data here
]
time_data = [(x[0] ** 2 + x[1] ** 2 + x[2] ** 2) ** 0.5 for x in time_data_raw]
seconds = 5 # how many seconds of data
sample_rate = int(len(time_data) / seconds) # how many samples per second
N = seconds * sample_rate
time = np.linspace(0, seconds, N)
frequency = np.linspace(0.0, sample_rate / 2, int(N/seconds))
freq_data = fft(time_data)
y = seconds/N * np.abs(freq_data[0:int(N/seconds)])
plt.plot(frequency, y)
plt.title('Frequency domain Signal')
plt.xlabel('Frequency in Hz')
plt.ylabel('Amplitude')
plt.show()

                            </code>
                        </pre>
                        
                        <p>
                            The measured time period is 5 seconds, during which the board is tapped ~10 times. The FFT output is plotted below.

                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/fft_output.png" width = 600 alt="..." /></a>
                            <span class="caption text-muted"> Accelerometer FFT output when the IMU board is tapped 10 times during a 5 second period. </span>

                            Despite the 0 Hz spike, we see multiple spikes, with decreasing amplitude as the frequency grows. The spike with the lowest frequency occurs at 5 Hz, which is surprisingly low. This could be due to either a) the sampling frequency is too low and we are looking at signal aliasing, or b) the oscillations of the board after tapping is falling into lower frequency ranges. (I acknowledge these hypothesis could be wrong as I am not a signal expert) This preliminary assessment really did not give me much insight of what cut-off frequency the low-pass filter should have, but in future labs I would start with a cut-off frequency of ~30 Hz, and tune it depending on the speed of the robot and the actual frequencies of the noise.
                        </p>

                        <p>
                            Note that the internal low-pass filter of the accelerometer is programmed to have a bandwidth of 473 Hz and the Nyquist bandwidth to be 499 Hz. Therefore, this result should have nothign to do with the misprogramming of the internal low-pass filter. (But well... who knows! It's our job as engineers to keep debugging!)
                        </p>

                        <p>
                            As for how the choice of cut-off frequency affects the output for a low pass filter, a lower cut-off frequency obviously will make sure the output changes slower than a higher cut-off frequency choice.
                        </p>

                        <h3 class="section-subheading">Gyroscope: pitch, roll, and yaw</h3>

                        <p>
                            The gyroscope measures angular velocity. Therefore, given the initial pitch, roll, and yaw angles, we can compute the pitch, roll, and yaw angles later in time from the gyroscope. Given an angle in time step <code>n</code>, we can do <code>theta_n+1 = theta_n + gyro_n * dt</code>, where <code>dt</code> is the time elapsed between the current and the previous measurement. Note that the <code>+</code> sign on the RHS of the equation could be <code>-</code> depending on the configuration of the board. Code snippet is attached below. The software uses the initial readings of the accelerometer as the initial orientation. At each later time step, it calculates the pitch and roll from both the accelerometer data and the gyroscope data, and outputs the difference.

                            <pre>
                                <code>
// Arduino library
// omit include statements

MyIMU my_imu;
bool first_time_running = true;
imu_data current_angles;
unsigned long last_measured_time;

void setup(void)
{
    Wire.begin();
    Wire.setClock(400000);

    Serial.begin(115200);

    Serial.println("IMU setup");
    my_imu.init();

    Serial.println("Sensors online!");
}

void loop(void)
{
    while (!my_imu.update_data())
    {
    };

    if (first_time_running)
    {   // take values from the accelerometer as the initial pitch, roll, and yaw
        first_time_running = false;
        imu_data acc = my_imu.get_acc();
        current_angles.y = atan(acc.x / acc.z) * 180 / 3.14159; // pitch
        current_angles.x = atan(acc.y / acc.z) * 180 / 3.14159; // roll
        last_measured_time = micros();
    }
    else
    {
        // compute acc pitch/roll
        imu_data acc = my_imu.get_acc();
        float acc_pitch = atan(acc.x / acc.z) * 180 / 3.14159;
        float acc_roll = atan(acc.y / acc.z) * 180 / 3.14159;
        Serial.print("Acc (pitch, roll) = ");
        Serial.print(acc_pitch);
        Serial.print(", ");
        Serial.print(acc_roll);

        // compute gyr pitch/roll
        imu_data gyr = my_imu.get_gyr();
        unsigned long elapsed_time = micros() - last_measured_time;
        last_measured_time = micros();
        current_angles.y = current_angles.y - float(elapsed_time) / 1000000 * gyr.y;
        current_angles.x = current_angles.x + float(elapsed_time) / 1000000 * gyr.x;
        
        Serial.print("    Gyr (pitch, roll) = ");
        Serial.print(current_angles.y);
        Serial.print(", ");
        Serial.print(current_angles.x);

        // compute acc/gyr difference
        Serial.print("    Diff (pitch, roll) = ");
        Serial.print(current_angles.y - acc_pitch);
        Serial.print(", ");
        Serial.print(current_angles.x - acc_roll);

        // show time elapsed
        Serial.print("    time_elapsed (ms) = ");
        Serial.print(elapsed_time / 1000);
    }

    Serial.println();
    delay(100); // modify to change sampling frequency
}

                                </code>
                            </pre>
                            The video below shows the difference output with the fastest sampling rate (<code>time step delay = 1 ms</code>).

                            <iframe width="820" height="515"
                            src="https://www.youtube.com/embed/Bg6LNFrmArw">
                            </iframe>
                            <span class="caption text-muted">Difference between Acc and Gyr Pitch/Roll reading with delay = 1 ms.</span>

                            From the video, we can see that pitch/roll data calculated from the gyroscope slowly drifts away. This is unavoidable due to the accumulation method for calculating pitch/roll from gyroscope readings. We can also see that when the board is flipped over 90 degrees, the difference has a sudden leap. The reason being <code>atan()</code> only returns within the range of -90 and 90 degrees, while the gyroscope data can go beyond 90 degrees. Futher heuristics could take care of this issue.

                            <iframe width="820" height="515"
                            src="https://www.youtube.com/embed/e-eaGQIlYEQ">
                            </iframe>
                            <span class="caption text-muted">Difference between Acc and Gyr Pitch/Roll reading with delay = 10 ms.</span>

                            <iframe width="820" height="515"
                            src="https://www.youtube.com/embed/2py7rLHkAAE">
                            </iframe>
                            <span class="caption text-muted">Difference between Acc and Gyr Pitch/Roll reading with delay = 100 ms.</span>

                            The two videos below show how longer sampling frequencies could impact the accuracy. I see that delay of 10 ms seems to perform better than both 1 ms and 100 ms. We could not use 100 ms in the actual robot because that is too slow, but 1 ms seems to be too noisy and it drifts away quicker. Note that this is only preliminary results, and the actual robot would need further tuning to achieve good performance.

                        </p>

                        <h3 class="section-subheading">Gyroscope: complimentary filter</h3>

                        <p>
                            From all the previous experiments, we can conclude that a) the accelerometer is very susceptible to noise, but it does not have the "drifting" issue that the gyroscope is experiencing, and b) the gyroscope is more robust against noise and sudden moves, but it has the drifting issue due to the integrating method for calculating pitch and roll. Therefore, we need a figure out a way to combine these two. A basic complimentary filter would use the following method:
                        </p>

                        <p><code>theta = (theta + gyr_reading * dt)*(1 - alpha) + acc_reading * alpha</code></p>

                        <p>Where <code>alpha</code> is a hyperparameter. <code>alpha = 1</code> would make <code>theta</code> behave exactly like the calculation from accelerometer, and <code>alpha = 0</code> would make it exactly the same as the gyroscope integrated readings. With an appropriate <code>alpha</code>, we can make the calculation of pitch/roll robust against both drifting and noise. I tested with <code>alpha = 0.8</code> and <code>alpha = 0.2</code></p>

                        <iframe width="820" height="515"
                        src="https://www.youtube.com/embed/KUl8s7UiG1I">
                        </iframe>
                        <span class="caption text-muted">Pitch/roll with complimentary filter. Alpha = 0.8</span>

                        <iframe width="820" height="515"
                        src="https://www.youtube.com/embed/ZKetu7A8zUc">
                        </iframe>
                        <span class="caption text-muted">Pitch/roll with complimentary filter. Alpha = 0.2</span>

                        <p>
                            From the video, we see that with a larger <code>alpha</code>, the readings are more susceptible to random noise and quick movements, and a smaller <code>alpha</code> yields a more desirable result where noise is less noticable. Both <code>alpha</code> is capable of overcoming the drifting issue. Therefore, I would like to conclude that <code>alpha <= 0.2</code> is the range we will be looking at in future labs.
                        </p>

                        <h3 class="section-subheading">A1: converting magnetometer data into a yaw angle</h3>

                        <p>
                            Turns out the magnetometer data can be used to determine the magnetic north orientation and calculate the yaw! (Not so much of a surprise, right?) Here is the formula provided by the instructor team:
                            
                            <pre>
                                <code>
xm = myICM.magX()*cos(pitch) - myICM.magY()*sin(roll)*sin(pitch) + myICM.magZ()*cos(roll)*sin(pitch);
ym = myICM.magY()*cos(roll) + myICM.magZ()*sin(roll_rad); 
yaw = atan2(ym, xm);
                                </code>
                            </pre>

                            With a little adaptation, I integrated into my code:
                            <pre>
                                <code>
float pitch = current_angles.y * 3.14159 / 180;
float roll = current_angles.x* 3.14159 / 180;
imu_data mag = my_imu.get_mag();
float xm = mag.x*cos(pitch) - mag.y*sin(roll)*sin(pitch) + mag.z*cos(roll)*sin(pitch);
float ym = mag.y*cos(roll) + mag.z*sin(roll); 
float yaw = atan2(ym, xm);
Serial.print("Yaw = ");
Serial.print(yaw);
                                </code>
                            </pre>

                            Two videos below demontrate its functionality. The first video shows that the magnetic North measured by the magnetometer is roughly the same as the geographic North, with the yaw changing as the orientation rotates. The second video shows that the yaw angle reading is robust against small changes in pitch.

                            <iframe width="820" height="515"
                            src="https://www.youtube.com/embed/HOA9C4QvOgA">
                            </iframe>
                            <span class="caption text-muted">Using the magnetometer readings to determine magnetic North.</span>

                            <iframe width="820" height="515"
                            src="https://www.youtube.com/embed/2fdUli-RsyU">
                            </iframe>
                            <span class="caption text-muted">The calculated yaw angle is robust against change in pitch.</span>

                            Maybe it's also possible to combine magnetometer data calculated yaw with gyroscope readings to be used in future labs? (I don't know!) But to conclude this (very, very long) lab, I am attaching my sensor wrapper classes below.
                        </p>


                        <h2 class="section-heading">Wrapper class: MyToFSensor</h2>
                        <p>
                            I made a wrapper to interface with the ToF sensors. Available methods include <code>MyToFSensors.init()</code> and <code>MyToFSensors.get_measurement()</code>, which are both self-explanatory.
                        </p>

                        <pre>
                            <code>
#ifndef TOF_SENSORS_END
#define TOF_SENSORS_END

// omit include statements
// Optional interrupt and shutdown pins.
#define SHUTDOWN_PIN_0 8
#define SHUTDOWN_PIN_1 7

typedef struct
{
    unsigned long measuring_time = 0;
    int distance = 0;
} distance_sensor_result;

class MyToFSensors
{
public:
    MyToFSensors(){};

    /**
     * @brief 
     * 
     * @param distance_mode 0 for short mode and 1 for long mode
     * @param budget timing budget in ms
     * @param period intermeasurement period in ms
     */
    void init(unsigned distance_mode = 0, unsigned int budget = 20, unsigned int period = 20)
    {
        this->two_sensor_setup(distance_mode, budget, period);
        this->start_ranging();
    }

    /**
     * @brief Get the measurement object
     *
     * @param sensor_idx
     * @return distance_sensor_result
     */
    distance_sensor_result get_measurement(int sensor_idx)
    {
        return sensor_idx ? this->read_distance(this->distanceSensor_1) : this->read_distance(this->distanceSensor_0);
    }

    void start_ranging()
    {
        this->distanceSensor_0.startRanging();
        this->distanceSensor_1.startRanging();
    }

private:
    /**
     * @brief 
     * 
     * @param distance_mode 0 for short mode and 1 for long mode
     * @param budget timing budget in ms
     * @param period intermeasurement period in ms
     */
    void two_sensor_setup(unsigned distance_mode, unsigned int budget, unsigned int period)
    {
        pinMode(SHUTDOWN_PIN_0, OUTPUT);
        pinMode(SHUTDOWN_PIN_1, OUTPUT);

        digitalWrite(SHUTDOWN_PIN_0, LOW);
        digitalWrite(SHUTDOWN_PIN_1, HIGH);

        if (this->distanceSensor_1.begin() != 0) // Begin returns 0 on a good init
        {
            Serial.println("Sensor 1 failed to begin. Please check wiring. Freezing...");
            while (1)
                ;
        }

        this->distanceSensor_1.setI2CAddress(0x60);

        digitalWrite(SHUTDOWN_PIN_0, HIGH);

        if (this->distanceSensor_0.begin() != 0) // Begin returns 0 on a good init
        {
            Serial.println("Sensor 0 failed to begin. Please check wiring. Freezing...");
            while (1)
                ;
        }

        // set distance mode here
        if (distance_mode)
        {
            this->distanceSensor_0.setDistanceModeLong();
            this->distanceSensor_1.setDistanceModeLong();
        }
        else
        {
            this->distanceSensor_0.setDistanceModeShort();
            this->distanceSensor_1.setDistanceModeShort();
        }

        Serial.print("Sensor 0 distance mode: ");
        Serial.println(this->distanceSensor_0.getDistanceMode());
        Serial.print("Sensor 1 distance mode: ");
        Serial.println(this->distanceSensor_1.getDistanceMode());

        // set timing budget here
        this->distanceSensor_0.setTimingBudgetInMs(budget);
        this->distanceSensor_0.setIntermeasurementPeriod(period);
        this->distanceSensor_1.setTimingBudgetInMs(budget);
        this->distanceSensor_1.setIntermeasurementPeriod(period);

        Serial.print("Sensor 0 timing budget: ");
        Serial.println(this->distanceSensor_0.getTimingBudgetInMs());
        Serial.print("Sensor 0 intermeasurement period: ");
        Serial.println(this->distanceSensor_0.getIntermeasurementPeriod());
        Serial.print("Sensor 1 timing budget: ");
        Serial.println(this->distanceSensor_1.getTimingBudgetInMs());
        Serial.print("Sensor 1 intermeasurement period: ");
        Serial.println(this->distanceSensor_1.getIntermeasurementPeriod());
    }

    /**
     * @brief
     *
     * @param distanceSensor
     * @return distance_sensor_result
     */
    distance_sensor_result read_distance(SFEVL53L1X &distanceSensor)
    {
        unsigned long start = millis();

        while (!distanceSensor.checkForDataReady())
        {
            delay(1);
        }
        int distance = distanceSensor.getDistance(); // Get the result of the measurement from the sensor
        distanceSensor.clearInterrupt();
        unsigned long stop = millis() - start;

        distance_sensor_result result;
        result.measuring_time = stop;
        result.distance = distance;

        return result;
    }

    SFEVL53L1X distanceSensor_0;
    SFEVL53L1X distanceSensor_1;
};

#endif
                            </code>
                        </pre>
                        
                        <h2 class="section-heading">Wrapper class: MyIMU</h2>
                        <p>
                            I also wrote a wrapper for the IMU. Methods include <code>MyIMU.init()</code>, <code>MyIMU.update_data()</code>, and <code>MyIMU.get_{acc/gyr/mag}()</code>. These methods are self-explanatory. Features to be added: calculate pitch/roll/yaw when needed.
                        </p>

                        <pre>
                            <code>
#ifndef MY_IMU
#define MY_IMU

// acc (mg), gyr (DPS), mag (uT)

// omit include statements

typedef struct
{
    float x = 0;
    float y = 0;
    float z = 0;
} imu_data;

class MyIMU
{
public:
    MyIMU(){};

    void init()
    {
        // necessary init steps
        bool initialized = false;
        while (!initialized)
        {

            myICM.begin(Wire, 0);

            Serial.print(F("Initialization of the sensor returned: "));
            Serial.println(myICM.statusString());
            if (myICM.status != ICM_20948_Stat_Ok)
            {
                Serial.println("Trying again IMU init...");
                delay(500);
            }
            else
            {
                initialized = true;
            }
        }

        // data scale
        // Set full scale ranges for both acc and gyr
        ICM_20948_fss_t myFSS; // This uses a "Full Scale Settings" structure that can contain values for all configurable sensors

        myFSS.a = gpm16; // (ICM_20948_ACCEL_CONFIG_FS_SEL_e)
                            // gpm2
                            // gpm4
                            // gpm8
                            // gpm16

        myFSS.g = dps250; // (ICM_20948_GYRO_CONFIG_1_FS_SEL_e)
                            // dps250
                            // dps500
                            // dps1000
                            // dps2000

        myICM.setFullScale((ICM_20948_Internal_Acc | ICM_20948_Internal_Gyr), myFSS);
        if (myICM.status != ICM_20948_Stat_Ok)
        {
            Serial.print(F("setFullScale returned: "));
            Serial.println(myICM.statusString());
        }

        // low-pass filter
        // Set up Digital Low-Pass Filter configuration
        ICM_20948_dlpcfg_t myDLPcfg;    // Similar to FSS, this uses a configuration structure for the desired sensors
        myDLPcfg.a = acc_d473bw_n499bw; // (ICM_20948_ACCEL_CONFIG_DLPCFG_e)
                                        // acc_d246bw_n265bw      - means 3db bandwidth is 246 hz and nyquist bandwidth is 265 hz
                                        // acc_d111bw4_n136bw
                                        // acc_d50bw4_n68bw8
                                        // acc_d23bw9_n34bw4
                                        // acc_d11bw5_n17bw
                                        // acc_d5bw7_n8bw3        - means 3 db bandwidth is 5.7 hz and nyquist bandwidth is 8.3 hz
                                        // acc_d473bw_n499bw

        myDLPcfg.g = gyr_d361bw4_n376bw5; // (ICM_20948_GYRO_CONFIG_1_DLPCFG_e)
                                            // gyr_d196bw6_n229bw8
                                            // gyr_d151bw8_n187bw6
                                            // gyr_d119bw5_n154bw3
                                            // gyr_d51bw2_n73bw3
                                            // gyr_d23bw9_n35bw9
                                            // gyr_d11bw6_n17bw8
                                            // gyr_d5bw7_n8bw9
                                            // gyr_d361bw4_n376bw5

        myICM.setDLPFcfg((ICM_20948_Internal_Acc | ICM_20948_Internal_Gyr), myDLPcfg);
        if (myICM.status != ICM_20948_Stat_Ok)
        {
            Serial.print(F("setDLPcfg returned: "));
            Serial.println(myICM.statusString());
        }
    }

    bool update_data()
    {
        if (myICM.dataReady())
        {
            myICM.getAGMT();
            this->store_data(); // store data in the class structs
            return true;
        }
        return false;
    }

    imu_data get_acc()
    {
        return acc;
    }

    imu_data get_gyr()
    {
        return gyr;
    }

    imu_data get_mag()
    {
        return mag;
    }

private:
    void store_data()
    {
        // accelerometer
        acc.x = myICM.accX();
        acc.y = myICM.accY();
        acc.z = myICM.accZ();

        // gyrometer
        gyr.x = myICM.gyrX();
        gyr.y = myICM.gyrY();
        gyr.z = myICM.gyrZ();

        // magnotometer
        mag.x = myICM.magX();
        mag.y = myICM.magY();
        mag.z = myICM.magZ();
    }

    imu_data acc;
    imu_data gyr;
    imu_data mag;
    ICM_20948_I2C myICM;
};

#endif /* MY_IMU */
                                
                            </code>
                        </pre>

                    </div>
                </div>
            </div>
        </article>
        <!-- Footer-->
        <footer class="border-top">
            <div class="container px-4 px-lg-5">
                <div class="row gx-4 gx-lg-5 justify-content-center">
                    <div class="col-md-10 col-lg-8 col-xl-7">
                        <ul class="list-inline text-center">
                            <li class="list-inline-item">
                                <a href="https://github.com/qd39l/fast-robots">
                                    <span class="fa-stack fa-lg">
                                        <i class="fas fa-circle fa-stack-2x"></i>
                                        <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                        </ul>
                        <div class="small text-center text-muted fst-italic">Copyright &copy; Fast Robots 2022</div>
                    </div>
                </div>
            </div>
        </footer>
        <!-- Bootstrap core JS-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Core theme JS-->
        <script src="js/scripts.js"></script>
    </body>
</html>
