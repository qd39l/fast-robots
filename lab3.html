<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="Github web page for ECE 5960: Design and Implementation of fast robots (2022SP)." />
        <meta name="author" content="Owen Deng (qd39@cornell.edu)" />
        <!-- FIXME -->
        <title>Fast Robots: Lab 3</title>
        <link rel="icon" type="image/x-icon" href="assets/ai.png" />
        <!-- Font Awesome icons (free version)-->
        <script src="https://use.fontawesome.com/releases/v5.15.4/js/all.js" crossorigin="anonymous"></script>
        <!-- Google fonts-->
        <link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css" />
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="css/styles.css" rel="stylesheet" />
    </head>
    <body>
        <!-- Navigation-->
        <nav class="navbar navbar-expand-lg navbar-light" id="mainNav">
            <div class="container px-4 px-lg-5">
                <a class="navbar-brand" href="index.html">Fast Robots: Lab Notebook</a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                    Menu
                    <i class="fas fa-bars"></i>
                </button>
                <div class="collapse navbar-collapse" id="navbarResponsive">
                    <ul class="navbar-nav ms-auto py-4 py-lg-0">
                        <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="index.html">Home</a></li>
                        <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="about.html">About</a></li>
                        <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="contact.html">Contact</a></li>
                    </ul>
                </div>
            </div>
        </nav>
        <!-- Page Header-->
        <!-- FIXME -->
        <header class="masthead" style="background-image: url('assets/img/lab3/background.jpg')">
            <div class="container position-relative px-4 px-lg-5">
                <div class="row gx-4 gx-lg-5 justify-content-center">
                    <div class="col-md-10 col-lg-8 col-xl-7">
                        <div class="post-heading">
                            <h1>Sensors</h1>
                            <h2 class="subheading">The Artemis board now becomes Doctor Octopus!</h2>
                            <span class="meta">
                                Posted by
                                <a href="#!">Owen Deng</a>
                                on February 22, 2022
                            </span>
                        </div>
                    </div>
                </div>
            </div>
        </header>
        <!-- Post Content-->
        <article class="mb-4">
            <div class="container px-4 px-lg-5">
                <div class="row gx-4 gx-lg-5 justify-content-center">
                    <div class="col-md-10 col-lg-8 col-xl-7">
                        <p> 
                            <mark>WARNING: This writeup is long because the lab is long... Please be aware...</mark>
                        </p>

                        <p> 
                            The goal of this lab is to connect the sensors to the robot, and to characterize the capabilities of the sensors we are using.
                            Intuitively, the capabilities of our robot is limited by the capabilities of the sensors. (we don't want the robot to be randomly 
                            crashing on things...) Therefore, the faster our sensors can sample data, the faster the robot can move. Similarly, more accurate
                            sensors lead to better control of the robot. In this course, the robot has three external sensing components: two Time-of-Flight 
                            Sensors (ToF) and an Inertial Measurement Unit (IMU). These sensors are provided by the course staff and they all come in the form
                            of breakout boards. </p>

                        <p> 
                            When it comes to sensors, it's important to have access to the sensors' specifications as well as their API libraries (unless we're writing
                            our own which we are not). For the ToF sensor (VL53L1X), we have access to the 
                            <a href="https://cdn.sparkfun.com/assets/e/1/8/4/e/VL53L1X_API.pdf" class="link-primary">manual</a>, 
                            the <a href="https://cdn.sparkfun.com/assets/8/9/9/a/6/VL53L0X_DS.pdf" class="link-primary">datasheet</a>, and the 
                            <a href="https://github.com/sparkfun/SparkFun_VL53L1X_Arduino_Library/blob/master/src/SparkFun_VL53L1X.h" class="link-primary">headerfile</a>
                            of the corresponding Arduino library. 
                            
                            For the IMU (ICM 20948), we have access to its 
                            <a href="https://invensense.tdk.com/wp-content/uploads/2016/06/DS-000189-ICM-20948-v1.3.pdf" class="link-primary">datasheet</a> and the 
                            <a href="https://github.com/sparkfun/SparkFun_ICM-20948_ArduinoLibrary" class="link-primary">Arduino library</a> for controlling this sensor.
                        </p>

                        <h2 class="section-heading">Hooking up the sensors</h2>
                        <p> 
                            All the external sensors communicate with the Artemis board via 
                            <a href="https://en.wikipedia.org/wiki/I%C2%B2C" class="link-primary">I2C protocol</a>. 
                            The Artemis board is the I2C controller, and the sensor components are I2C targets. (Many are more familiar with the nomenclature "master/slave", which
                            was updated in 
                            <a href="https://www.nxp.com/docs/en/user-guide/UM10204.pdf" class="link-primary">I2C Spec Rev. 07</a>.)
                        </p>

                        <p>
                            Wiring between the Artemis board and the sensor boards are straight-forward. Coming from the I2C protocl, each sensor board needs at least four connections ( 
                            <code>Vin</code>,
                            <code>Ground</code>,
                            <code>SDA</code>, and 
                            <code>SCL</code>) to the Artemis controller for data exchange to work. The picture below shows the pinout of each board. I have soldered jump wire connectors
                            onto the boards.
                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/sensor-headers.jpg" width = 400 alt="..." /></a>
                            <span class="caption text-muted">Pinout of sensor boards. The green one on top is the ToF sensor. The black one below is the IMU.</span>

                            Notice that both boards have the four necessary signal pins available. In a "one controller, many target" setup, the same signals from each board share the same electrical node, e.g., 
                            the <code>SDA</code> pin of the Artemis board is connected to the <code>SDA</code> pin of both ToF boards and the IMU board. 
                        </p>

                        <p>
                            With some soldering work done, the Artemis board essentially turns into Doc Ock... See the picture below
                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/wiring.jpg" width = 600 alt="..." /></a>
                            <span class="caption text-muted">The Artemis board connected to the sensors.</span>

                            To summarize my wiring:
                            <ul class="list-unstyled">
                                <ul>
                                  <li>Some jump wire pins are soldered to a protoboard. The protoboard is used for better cable management. Connections are made on the back. </li>
                                  <li>Both ToF sensors' <code>XSHUT</code> pins are wired to a GPIO pin (<code>PIN7</code> & <code>PIN8</code> used) on the Artemis board (with jump wire connection). This is needed because both ToF sensors 
                                      share the same I2C address.</li>
                                  <li>Cables are braided because I found it fun.</li>
                                </ul>
                            </ul>
                            
                            I chose jump wire connections to hopefully avoid any future re-work and improved modularity. Also note that the Artemis board has the 
                            <a href="https://www.sparkfun.com/qwiic" class="link-primary">SparkFun Qwiic Connect System</a> for cleaner I2C connections on the board.

                            
                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/wiring-closeup1.jpg" width = 600 alt="..." /></a>
                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/wiring-closeup2.jpg" width = 600 alt="..." /></a>
                            <span class="caption text-muted">Shows the wiring between the Artemis board and the sensors (two perspectives).</span>

                        </p>
                        
                        <h2 class="section-heading">Software preparation</h2>
                        Two Arduino libraries need to be installed so that we can access the API for interacting with the sensors.
                        <ul class="list-unstyled">
                            <ul>
                              <li>SparkFun VL53L1X 4m laser distance sensor library <a href="https://github.com/sparkfun/SparkFun_VL53L1X_Arduino_Library" class="link-primary">(source code)</a></li>
                              <li>SparkFun 9DOF IMU Breakout - ICM 20948 <a href="https://github.com/sparkfun/SparkFun_ICM-20948_ArduinoLibrary" class="link-primary">(source code)</a></li>
                            </ul>
                        </ul>

                        <mark>Assuming everything is set up properly (in reality some circuit debugging efforts were involved for sure...), let's hop on to the actual lab tasks!! </mark>

                        <h2 class="section-heading">Lab 3(a): Time of Flight sensors</h2>
                        <h3 class="section-subheading">I2C addresses</h3>
                        <p>
                            To instructors: I didn't run the Wire example since it doesn't work well... I jumped straight into the read-distance example, and completed the two sensor setup.
                        </p>

                        <h3 class="section-subheading">Sensing modes and sensor characterizations</h3>
                        <p>
                            The <a href="https://cdn.sparkfun.com/assets/e/1/8/4/e/VL53L1X_API.pdf" class="link-primary">API document</a> claims there are three distance modes in in section 2.5.3. However, the <a href="https://github.com/sparkfun/SparkFun_VL53L1X_Arduino_Library/blob/master/src/SparkFun_VL53L1X.h" class="link-primary">SparkFun API headerfile</a> only provides two distance modes. Therefore, we assume only two distance modes are accessible by the user (myself). The table below summarizes the pros/cons of each mode. To determine which mode to be used, I conducted some characterizations on the sensors.

                            <table class="table">
                                <thead>
                                  <tr>
                                    <th scope="col">Possible distance modes</th>
                                    <th scope="col">Maximum distance</th>
                                    <th scope="col">Benefit/comments</th>
                                  </tr>
                                </thead>
                                <tbody>
                                  <tr>
                                    <th scope="row">Short (default)</th>
                                    <td>Up to 1.3 m</td>
                                    <td>Better ambient immunity</td>
                                  </tr>
                                  <tr>
                                    <th scope="row">Long</th>
                                    <td>Up to 4 m</td>
                                    <td>Maximum distance</td>
                                  </tr>
                                </tbody>
                            </table>
                            <span class="caption text-muted">A summary of the two distance modes available on VL53L1X.</span>
                        </p>

                        <h4 class="section-subsubheading">1. Distance modes and accuracy</h4>

                        <p>
                            To investigate the impact of distance modes, I conducted a sweep of measured distances and the actual distances for the two modes. The sensor module is mounted on the back of my laptop. The sensor module is facing a wall, and a ruler is used to measure the distance between itself and the wall. Measured data are streamed to the laptop through the serial port. Pictures below shows the setup.

                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/distance-setup1.jpg" width = 600 alt="..." /></a>
                            <span class="caption text-muted">The laptop is facing the wall. Artemis is connected to the laptop, and data is read on the Serial monitor. </span>

                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/distance-setup2.jpg" width = 600 alt="..." /></a>
                            <span class="caption text-muted">The sensor module is mounted on the back of the laptop. The paper is necessary because the laptop surface is conductive. (took me a while to debug) </span>
                        </p>

                        <p>
                            Data are visualized with Matplotlib. 

                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/distance-plot.png" width = 600 alt="..." /></a>
                            <span class="caption text-muted"> Plotting the ref distance and the measured distances with two different measurement modes. </span>

                            Some important findings include:

                            <ul class="list-unstyled">
                                <ul>
                                  <li>Both short and long mode data are off for longer ref distance. This could be due to misalignments of the laptop and the wall. Just looking at the green and orange line, they are consistent.</li>
                                  <li>The short mode is rated for up to 1.3m, but turns out it is doing okay when going up to 2m.</a></li>
                                </ul>
                            </ul>

                            <mark>The ranging time</mark> is also measured. One sensor needs a consistent <code>87 ms</code> while another sensor only needs <code>3 ms</code>. The reason is unknown after some investigation efforts. <mark>The ranging time is independent of distance and/or distancing modes.</mark>
                        </p>

                        <h4 class="section-subsubheading">2. Lighting conditions, colors, and textures</h4>
                        <p>
                            The impact of lighting conditions, colors, and textures are also investigated. The sensor is placed 30 cm away from a white box. Their positions are kept the same throughout this experiment, while other factors are tuned. 50 measurements are taken, and the mean is reported. Because 30 cm is short, the short distancing mode is chosen throughout. The table blow summarizes my findings.

                            <table class="table">
                                <thead>
                                  <tr>
                                    <th scope="col">Distance modes</th>
                                    <th scope="col">Color</th>
                                    <th scope="col">Texture</th>
                                    <th scope="col">Lighting</th>
                                    <th scope="col">Measured Distance (mm)</th>
                                  </tr>
                                </thead>
                                <tbody>
                                  <tr>
                                    <td>Short</td>
                                    <td>White</td>
                                    <td>Smooth</td>
                                    <td>Ambient (LED)</td>
                                    <td>294</td>
                                  </tr>
                                  <tr>
                                    <td>Short</td>
                                    <td>White</td>
                                    <td>Smooth</td>
                                    <td>Bright Incandescent</td>
                                    <td>297</td>
                                  </tr>
                                  <tr>
                                    <td>Short</td>
                                    <td>White</td>
                                    <td>Smooth</td>
                                    <td>Dark</td>
                                    <td>301</td>
                                  </tr>
                                  <tr>
                                    <td>Short</td>
                                    <td>White</td>
                                    <td>Cloth</td>
                                    <td>Ambient (LED)</td>
                                    <td>298</td>
                                  </tr>
                                  <tr>
                                    <td>Short</td>
                                    <td>Blue</td>
                                    <td>Cloth</td>
                                    <td>Ambient (LED)</td>
                                    <td>300</td>
                                  </tr>
                                </tbody>
                            </table>
                            <span class="caption text-muted">Table summarizing the impacts of lighting conditions, colors, and textures.</span>

                            The pictures below show my setup for this experiment.
                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/distance-setup3.jpg" width = 600 alt="..." /></a>
                            <span class="caption text-muted"> The laptop and the box. </span>
                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/distance-setup4.jpg" width = 600 alt="..." /></a>
                            <span class="caption text-muted"> The incandescent light. </span>
                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/distance-setup5.jpg" width = 600 alt="..." /></a>
                            <span class="caption text-muted"> The box wrapped in blue cloth. </span>

                            In conclusion, with the short distancing mode, the ToF sensor is not affected by lighting conditions, colors, and textures. <mark>Given these characterization results, I decide to go with the short distancing mode because a) it works for up to 2m without any obvious issues, b) it is robust against lighting conditions, colors, and textures, and c) it is the default mode so programming becomes a little bit easier.</mark>
                        </p>

                        <h4 class="section-subsubheading">Code Snippets</h4>
                        <p>
                            A wrapper class, <code>MyToFSensor</code>, is created to interface with the ToF sensor modules. The details of this wrapper class is attached to the end of this page. This section assumes the existance of this class and provides a high-level view of how the Artemis is set up for this experiment. The program simply gets the measurement and the time for measuring, and pipes the result to the Serial monitor for me to view.

                            <pre>
                                <code>
// Arduino library
#include &ltArduino.h&gt
#include &ltWire.h&gt

// my ToF sensor wrapper
#include "tof_sensors.h"

MyToFSensor my_tof;

void setup(void)
{
    Wire.begin();

    // TOF init
    Serial.begin(115200);
    Serial.println("ToF setup");
    my_tof.init();
    Serial.println("Sensor online!");
}

void loop(void)
{
    Serial.print("Sensor0 Distance(mm): ");
    distance_sensor_result sensor0_result = my_tof.get_measurement(0);
    Serial.print(sensor0_result.distance);
    Serial.print(" Sensor0 time(ms): ");
    Serial.print(sensor0_result.measuring_time);

    Serial.print("      Sensor1 Distance(mm): ");
    distance_sensor_result sensor1_result = my_tof.get_measurement(1);
    Serial.print(sensor1_result.distance);
    Serial.print(" Sensor1 time(ms): ");
    Serial.print(sensor1_result.measuring_time);

    Serial.println();
}

                                </code>
                            </pre>
                        </p>


                        <h3 class="section-subheading">Working with two sensors simultaneously</h3>
                        <p>
                            There are a total of 2 ToF sensor modules on the same I2C channel. They have the same I2C address, so additional setups are needed to use them simultaneously.
                        </p>

                        <p>
                            During sensor initialization, the <code>XSHUT</code> pin of one sensor is asserted <code>LOW</code>. Then the init method of the other sensor is called, and subsequently its I2C address is modified. After that, the <code>XSHUT</code> pin is pulled high, bring the first sensor back online with the default address. At this point, two ToF sensors have different I2C addresses, and they can be used simultaneously. Code snippet attached below.

                            <pre>
                                <code>
pinMode(SHUTDOWN_PIN_0, OUTPUT);
pinMode(SHUTDOWN_PIN_1, OUTPUT);

digitalWrite(SHUTDOWN_PIN_0, LOW);
digitalWrite(SHUTDOWN_PIN_1, HIGH);

if (this->distanceSensor_1.begin() != 0) // Begin returns 0 on a good init
{
    Serial.println("Sensor 1 failed to begin. Please check wiring. Freezing...");
    while (1)
        ;
}

this->distanceSensor_1.setI2CAddress(0x60);

digitalWrite(SHUTDOWN_PIN_0, HIGH);

if (this->distanceSensor_0.begin() != 0) // Begin returns 0 on a good init
{
    Serial.println("Sensor 0 failed to begin. Please check wiring. Freezing...");
    while (1)
        ;
}
                                </code>
                            </pre>

                        </p>

                        <h3 class="section-subheading">A1: Discussion on infrared transmission distance sensors</h3>

                        <p>
                            Many distance sensors are based on infrared transmission, including IR distance sensors, LiDAR, and Time-of-Flight sensors.  
                        </p>

                        <p>
                            IR distance sensors are cheap. Measurement is based on the reflected angle of the beam. The picture below is an intuitive picture of its working principle.

                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/IR.jpg" width = 600 alt="..." /></a>
                            <span class="caption text-muted"> IR distance sensor working principle. Source: https://os.mbed.com/forum/mbed/topic/1048/?page=1#comment-6420 </span>

                            Despite its cheap price and better relibaility than an even-cheaper ultrasonic proximity sensor, it is not able to measure accurately for long distance. As the distance gets longer, the change of angle becomes smaller and undetectable. They also fail if the object is highly reflective (like a mirror).
                        </p>

                        <p>
                            ToF sensors take advantages of the constant speed of light. The picture below shows its principle. The emitter sends a pulse of EM wave, which is reflected by the objected and later picked up by the receiver. The distance between the sensor and the object and then be calculated from the time between the emitter sends the pulse and the receiver picks up the pulse.

                            <a href="#!"><img class="img-fluid" src="assets/img/lab3/tof.png" width = 600 alt="..." /></a>
                            <span class="caption text-muted"> ToF sensors principle. Source: https://en.wikipedia.org/wiki/Time_of_flight </span>

                            ToF sensors are better in long distance sensing, and the sampling frequency is typically higher. However, this comes with the cost of being more expensive than IR proximity sensors.
                        </p>

                        <p>
                            LiDAR uses a similar principle as ToF sensors: pulsed lasers are used, and the travelling time of the pulsed is used to calculate the distance. However, LiDAR typically uses an array of emitters and receivers, making them better in doing 3D sensing and imaging, and they are more robust than ToF sensors. This comes with the cost of being very expensive compared to other IR-based sensors. (fancy!)
                        </p>

                        <p>
                            Reference for writing this section:
                            <ul class="list-unstyled">
                                <ul>
                                  <li>https://www.makeuseof.com/tof-and-lidar-difference/</li>
                                  <li>https://www.seeedstudio.com/blog/2019/12/23/distance-sensors-types-and-selection-guide/</li>
                                  <li>https://www.sparkfun.com/distance_sensor_comparison_guide</li>
                                </ul>
                            </ul>
                        </p>

                        <h3 class="section-subheading">A2: Timing budget</h3>

                        <p>
                            Recall that earlier in this article, I reported that one sensor needs a consistent <code>87 ms</code> while another sensor only needs <code>3 ms</code> when doing a measurement. This section could shine some light on why that was the case.
                        </p>

                        <p>
                            Each ToF sensor can be configured with a <mark>timing budget</mark> and an <mark>inter-measurement period</mark>, both in milliseconds. Timing budget is the time required by the sensor to perform one range measurement, and the inter-measurement period is the delay between two ranging operations. The minimum and maximum timing budgets are [<code>20 ms</code>, <code>1000 ms</code>]. 

                            I first read out the default values.

                            <pre>
                                <code>
Serial.print("Sensor 0 timing budget: ");
Serial.println(this->distanceSensor_0.getTimingBudgetInMs());
Serial.print("Sensor 0 intermeasurement period: ");
Serial.println(this->distanceSensor_0.getIntermeasurementPeriod());
Serial.print("Sensor 1 timing budget: ");
Serial.println(this->distanceSensor_1.getTimingBudgetInMs());
Serial.print("Sensor 1 intermeasurement period: ");
Serial.println(this->distanceSensor_1.getIntermeasurementPeriod());
                                </code>
                            </pre>

                            The sensors have the following default configurations:
                            <table class="table">
                                <thead>
                                  <tr>
                                    <th scope="col">Sensor Number</th>
                                    <th scope="col">Intermeasurement Period (ms)</th>
                                    <th scope="col">Timing Budget (ms)</th>
                                  </tr>
                                </thead>
                                <tbody>
                                  <tr>
                                    <td>0</td>
                                    <td>100</td>
                                    <td>0</td>
                                  </tr>
                                  <tr>
                                    <td>1</td>
                                    <td>98</td>
                                    <td>0</td>
                                  </tr>
                                </tbody>
                            </table>
                            Weirdly, not only both timing budgets are default to 0, the intermeasurement period are also different... despite they are the exact same module. This may (or may not) explain why one sensor's reading time is much longer than the other.
                        </p>

                        <p>
                            Then I poked with the numbers and obtained the following numbers.

                            <table class="table">
                                <thead>
                                  <tr>
                                    <th scope="col">Sensor Number</th>
                                    <th scope="col">Intermeasurement Period (ms)</th>
                                    <th scope="col">Timing Budget (ms)</th>
                                    <th scope="col">Measuring Time (ms)</th>
                                  </tr>
                                </thead>
                                <tbody>
                                  <tr>
                                    <td>0</td>
                                    <td>0</td>
                                    <td>20</td>
                                    <td>Fail to take measurements</td>
                                  </tr>
                                  <tr>
                                    <td>1</td>
                                    <td>0</td>
                                    <td>20</td>
                                    <td>Fail to take measurements</td>
                                  </tr>
                                  <tr>
                                    <td>0</td>
                                    <td>20</td>
                                    <td>20</td>
                                    <td>4</td>
                                  </tr>
                                  <tr>
                                    <td>1</td>
                                    <td>20</td>
                                    <td>20</td>
                                    <td>10</td>
                                  </tr>
                                  <tr>
                                    <td>0</td>
                                    <td>100</td>
                                    <td>100</td>
                                    <td>60</td>
                                  </tr>
                                  <tr>
                                    <td>1</td>
                                    <td>100</td>
                                    <td>100</td>
                                    <td>80</td>
                                  </tr>
                                </tbody>
                            </table>

                            I did not notice any reliability issues associated with the change of these two configurations.
                        </p>

                        <p>
                            A longer intermeasurement period can save energy (the module goes into low-power mode when idle). However, energy is out of our concern since the robot is not designed to move for a long time. It is expected to move FAST! <mark>Therefore, I decided to set both values to <code>20 ms</code> for subsequent labs because I want the robot to be able to take samples as quickly as possible. Such that it can move and respond as fast as possible!</mark>
                        </p>

                        <h3 class="section-subheading">A3: Signal and Sigma: is the measurement valid?</h3>
                        <p>
                            The driver uses two parameters to qualify the ranging measurement: signal and sigma. If signal or sigma are outside the limits, the ranging is flagged as invalid.
                        </p>

                        <p>
                            Sigma is expressed in mm and is the estimation of the standard deviation of the measurement. The signal rate measurement represents the amplitude of the signal reflected from the target and detected by the device. Therefore, a small sigma and a large signal corresponds to a strong confidence in the measurement. The driver associates these two values with a tolerance limit. If signal or sigma are outside the limits, the ranging is flagged as invalid. The video below shows the results of running <code>Example3_StatusAndRate</code> of the ToF sensor library. 
                        </p>

                        <iframe width="820" height="515"
                        src="https://www.youtube.com/embed/qioRD9hZa0o">
                        </iframe>
                        <span class="caption text-muted">Demo of running <code>Example3_StatusAndRate</code>.</span>
                        
                        <p>
                            In the demo video, the ToF sensor is quickly flipped around. Whenever flipping happens, there are one or two data points where the range status shows "Signal fail" or "Wrapped target fail" (no signal detected). This provides a mean for us to filter out invalid readings. In future labs, we can implement checks against these invalid signals to make our robot more robust, especially when it is moving fast.
                        </p>

                        <h2 class="section-heading">Lab 3(b): IMU</h2>

                        <h3 class="section-subheading">IMU setup and examples</h3>

                        Note the AD0_VAL definition. What does it represent, and should it be 0 or 1?
                        Check out the change in sensor values as you rotate, flip, and accelerate the board. Explain what you see in both acceleration and gyroscope data.

                        <h3 class="section-subheading">Accelerometer: pitch and roll</h3>

                        <h3 class="section-subheading">Accelerometer: tapping</h3>

                        <h3 class="section-subheading">Gyroscope: pitch, roll, and yaw</h3>

                        <h3 class="section-subheading">Gyroscope: complimentary filter</h3>

                        <h3 class="section-subheading">A1: converting magnetometer data into a yaw angle</h3>

                        <h2 class="section-heading">Wrapper class: MyToFSensor</h2>


                    </div>
                </div>
            </div>
        </article>
        <!-- Footer-->
        <footer class="border-top">
            <div class="container px-4 px-lg-5">
                <div class="row gx-4 gx-lg-5 justify-content-center">
                    <div class="col-md-10 col-lg-8 col-xl-7">
                        <ul class="list-inline text-center">
                            <li class="list-inline-item">
                                <a href="https://github.com/qd39l/fast-robots">
                                    <span class="fa-stack fa-lg">
                                        <i class="fas fa-circle fa-stack-2x"></i>
                                        <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                        </ul>
                        <div class="small text-center text-muted fst-italic">Copyright &copy; Fast Robots 2022</div>
                    </div>
                </div>
            </div>
        </footer>
        <!-- Bootstrap core JS-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Core theme JS-->
        <script src="js/scripts.js"></script>
    </body>
</html>
